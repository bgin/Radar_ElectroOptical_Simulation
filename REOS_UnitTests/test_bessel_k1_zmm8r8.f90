


!/*MIT License
!Copyright (c) 2020 Bernard Gingold
!Permission is hereby granted, free of charge, to any person obtaining a copy
!of this software and associated documentation files (the "Software"), to deal
!in the Software without restriction, including without limitation the rights
!to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
!copies of the Software, and to permit persons to whom the Software is
!furnished to do so, subject to the following conditions:
!The above copyright notice and this permission notice shall be included in all
!copies or substantial portions of the Software.
!THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
!IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
!FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
!AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
!LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
!OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
!SOFTWARE.
!*/

module mod_test_bessel_k1_zmm8r8


       use mod_kinds,     only : i4, dp 
       use mod_vectypes,  only : ZMM8r8_t, Mask8_t
       use iso_c_binding, only : c_int, c_long_long 
     

       integer(kind=c_long_long),       parameter :: RDTSC_LATENCY = 18 ! for Skylake arch.
       integer(kind=c_long_long),       parameter :: ZERO          = 0_c_long_long 

#if 0
    ICC and ifort commands
    icc -c -std=c99 GMS_intrinsics_wrappers.c
    ifort -o test_bessel_k1_zmm8r8 -fp-model fast=2 -ftz -O3 -ggdb  -xHost \
    -fopenmp -qopenmp -fpp -falign-functions=32 -qopt-report=5 GMS_config.fpp GMS_kinds.f90 GMS_vectypes.f90 GMS_spec_func_zmm8r8.f90 GMS_mod_fpcompare.f90 GMS_intrinsics_wrappers.o test_bessel_k1_zmm8r8.f90
    
    -------------------------------------------------------------------------------------------------------------------------------------------------
    For assembly only:
    ifort -S -fp-model fast=2 -ftz -O3 -ggdb  -xHost \
     -fopenmp -qopenmp -fpp -falign-functions=32 -qopt-report=5 GMS_config.fpp GMS_kinds.f90 GMS_vectypes.f90 GMS_spec_func_zmm8r8.f90 GMS_mod_fpcompare.f90 GMS_intrinsics_wrappers.o test_bessel_k1_zmm8r8.f90
      
#endif

      contains 

function besk1 ( x )

!*****************************************************************************80
!
!! BESK1 evaluates the Bessel K1(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for the
!    modified Bessel function of the second kind of order one
!    for arguments XLEAST <= ARG <= XMAX.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the argument of the function.
!
!    Output, real ( kind = 8 ) BESK1, the value of the function.
!
  implicit none

  real ( kind = 8 ) besk1
  integer ( kind = 4 ) jint
  real ( kind = 8 ) result
  real ( kind = 8 ) x

  jint = 1
  call calck1 ( x, result, jint )
  besk1 = result

  return
end function 

subroutine calck1 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCK1 computes various K1 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the second kind
!    and order one, K1(X) and EXP(X)*K1(X), for real arguments X.
!
!    The main computation evaluates slightly modified forms of near
!    minimax rational approximations generated by Russon and Blair,
!    Chalk River (Atomic Energy of Canada Limited) Report AECL-3461,
!    1969.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) ARG, the argument.  XLEAST < ARG is
!    always required.  If JINT = 1, then the argument must also be
!    less than XMAX.
!
!    Output, real ( kind = 8 ) RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = K1(x);
!    2, RESULT = exp(x) * K1(x);
!
!    Input, integer ( kind = 4 ) JINT, chooses the function to be computed.
!    1, K1(x);
!    2, exp(x) * K1(x);
!
  implicit none

  real ( kind = 8 ) arg
  real ( kind = 8 ) f(5)
  real ( kind = 8 ) g(3)
  integer ( kind = 4 ) i
  integer ( kind = 4 ) jint
  real ( kind = 8 ) one
  real ( kind = 8 ) p(5)
  real ( kind = 8 ) pp(11)
  real ( kind = 8 ) q(3)
  real ( kind = 8 ) qq(9)
  real ( kind = 8 ) result
  real ( kind = 8 ) sumf
  real ( kind = 8 ) sumg
  real ( kind = 8 ) sump
  real ( kind = 8 ) sumq
  real ( kind = 8 ) x
  real ( kind = 8 ) xinf
  real ( kind = 8 ) xmax
  real ( kind = 8 ) xleast
  real ( kind = 8 ) xsmall
  real ( kind = 8 ) xx
  real ( kind = 8 ) zero
!
!  Mathematical constants
!
  data one /1.0d0/
  data zero /0.0d0/
!
!  Machine-dependent constants
!
  data xleast /2.23d-308/
  data xsmall /1.11d-16/
  data xinf /1.79d+308/
  data xmax /705.343d+0/
!
!  Coefficients for  XLEAST <=  ARG  <= 1.0
!
  data   p/ 4.8127070456878442310d-1, 9.9991373567429309922d+1, &
            7.1885382604084798576d+3, 1.7733324035147015630d+5, &
            7.1938920065420586101d+5/
  data   q/-2.8143915754538725829d+2, 3.7264298672067697862d+4, &
           -2.2149374878243304548d+6/
  data   f/-2.2795590826955002390d-1,-5.3103913335180275253d+1, &
           -4.5051623763436087023d+3,-1.4758069205414222471d+5, &
           -1.3531161492785421328d+6/
  data   g/-3.0507151578787595807d+2, 4.3117653211351080007d+4, &
           -2.7062322985570842656d+6/
!
!  Coefficients for  1.0 < ARG
!
  data  pp/ 6.4257745859173138767d-2, 7.5584584631176030810d+0, &
            1.3182609918569941308d+2, 8.1094256146537402173d+2, &
            2.3123742209168871550d+3, 3.4540675585544584407d+3, &
            2.8590657697910288226d+3, 1.3319486433183221990d+3, &
            3.4122953486801312910d+2, 4.4137176114230414036d+1, &
            2.2196792496874548962d+0/
  data  qq/ 3.6001069306861518855d+1, 3.3031020088765390854d+2, &
            1.2082692316002348638d+3, 2.1181000487171943810d+3, &
            1.9448440788918006154d+3, 9.6929165726802648634d+2, &
            2.5951223655579051357d+2, 3.4552228452758912848d+1, &
            1.7710478032601086579d+0/

  x = arg
!
!  Error return for ARG < XLEAST.
!
  if ( x < xleast ) then

    result = xinf
!
!  XLEAST <= ARG <= 1.0.
!
  else if ( x <= one ) then

    if ( x < xsmall ) then
!
!  Return for small ARG.
!
      result = one / x

    else

      xx = x * x

      sump = (((( &
               p(1) &
        * xx + p(2) ) &
        * xx + p(3) ) &
        * xx + p(4) ) &
        * xx + p(5) ) &
        * xx + q(3)

      sumq = (( &
          xx + q(1) ) &
        * xx + q(2) ) &
        * xx + q(3)

      sumf = ((( &
               f(1) &
        * xx + f(2) ) &
        * xx + f(3) ) &
        * xx + f(4) ) &
        * xx + f(5)

      sumg = (( &
          xx + g(1) ) &
        * xx + g(2) ) &
        * xx + g(3)

      result = ( xx * log ( x ) * sumf / sumg + sump / sumq ) / x

      if ( jint == 2 ) then
        result = result * exp ( x )
      end if

    end if

  else if ( jint == 1 .and. xmax < x ) then
!
!  Error return for XMAX < ARG.
!
    result = zero

  else
!
!  1.0 < ARG.
!
    xx = one / x

    sump = pp(1)
    do i = 2, 11
      sump = sump * xx + pp(i)
    end do

    sumq = xx
    do i = 1, 8
      sumq = ( sumq + qq(i) ) * xx
    end do
    sumq = sumq + qq(9)

    result = sump / sumq / sqrt ( x )

    if ( jint == 1 ) then
      result = result * exp ( -x )
    end if

  end if

  return
end subroutine 

subroutine unit_test_bessel_k1_zmm8r8()
           use spec_func_zmm8r8, only : besk1_zmm8r8, calck1_zmm8r8
           use mod_fpcompare 
           use iso_c_binding, only : c_int, c_long_long 
           use IFPORT 
           !use , intrinsic           :: IEEE_ARITHMETIC
           implicit none 
#if 0
              interface
                  function raise(sig) bind(C,name="raise")
                           use iso_c_binding, only : c_int 
                           integer(c_int) :: raise 
                           integer(c_int), value :: sig 
                  end function raise 
              end interface
#endif
              interface 
                   function rdtsc_wrap() bind(C,name="rdtsc_wrap")
                            use iso_c_binding, only : c_long_long 
                            integer(c_long_long) :: rdtsc_wrap 
                    end function rdtsc_wrap 
              end interface
              character(len=60),           parameter  :: header = "[TEST #1:  besk1_zmm8r8 -- START]"
              character(len=60),           parameter  :: footer = "[TEST #1:  besk1_zmm8r8 -- END]"
              integer(kind=c_long_long),   automatic  :: start, end 
              integer(kind=c_long_long),   automatic  :: start_c, end_c,tsc_elapsed
              real(kind=dp),dimension(20), parameter  :: x_args     = [&
                                                                     0.1e+00_dp, &
                                                                     0.2e+00_dp, &
                                                                     0.4e+00_dp, &
                                                                     0.6e+00_dp, &
                                                                     0.8e+00_dp, &
                                                                     1.0e+00_dp, &
                                                                     1.2e+00_dp, &
                                                                     1.4e+00_dp, &
                                                                     1.6e+00_dp, &
                                                                     1.8e+00_dp, &
                                                                     2.0e+00_dp, &
                                                                     2.5e+00_dp, &
                                                                     3.0e+00_dp, &
                                                                     3.5e+00_dp, &
                                                                     4.0e+00_dp, &
                                                                     4.5e+00_dp, &
                                                                     5.0e+00_dp, &
                                                                     6.0e+00_dp, &
                                                                     8.0e+00_dp, &
                                                                     10.0e+00_dp ]
              real(kind=dp),dimension(20), parameter  :: fx_results = [&
                                                                      0.9853844780870606e+01_dp, &
                                                                      0.4775972543220472e+01_dp, &
                                                                      0.2184354424732687e+01_dp, &
                                                                      0.1302834939763502e+01_dp, &
                                                                      0.8617816344721803e+00_dp, &
                                                                      0.6019072301972346e+00_dp, &
                                                                      0.4345923910607150e+00_dp, &
                                                                      0.3208359022298758e+00_dp, &
                                                                      0.2406339113576119e+00_dp, &
                                                                      0.1826230998017470e+00_dp, &
                                                                      0.1398658818165224e+00_dp, &
                                                                      0.7389081634774706e-01_dp, &
                                                                      0.4015643112819418e-01_dp, &
                                                                      0.2223939292592383e-01_dp, &
                                                                      0.1248349888726843e-01_dp, &
                                                                      0.7078094908968090e-02_dp, &
                                                                      0.4044613445452164e-02_dp, &
                                                                      0.1343919717735509e-02_dp, &
                                                                      0.1553692118050011e-03_dp, &
                                                                      0.1864877345382558e-04_dp ] 
             type(ZMM8r8_t),                parameter  :: X_ARG1    = ZMM8r8_t([0.1E+00_dp,0.2E+00_dp,   &
                                                                                0.4E+00_dp,0.6E+00_dp,   &
                                                                                0.8E+00_dp,0.1E+01_dp,   &
                                                                                0.12E+01_dp,0.14E+01_dp])
             type(ZMM8r8_t),                parameter  :: X_ARG2    = ZMM8r8_t([0.16E+01_dp,0.18E+01_dp, &
                                                                                0.20E+01_dp,0.25E+01_dp, &
                                                                                0.30E+01_dp,0.35E+01_dp, &
                                                                                0.40E+01_dp,0.45E+01_dp])
                                      
             type(ZMM8r8_t),                parameter  :: FX_RES1   = ZMM8r8_t([0.9853844780870606e+01_dp,0.4775972543220472e+01_dp, &
                                                                                0.2184354424732687e+01_dp,0.1302834939763502e+01_dp, &
                                                                                0.8617816344721803e+00_dp,0.6019072301972346e+00_dp, &
                                                                                0.4345923910607150e+00_dp,0.3208359022298758e+00_dp])
             type(ZMM8r8_t),                parameter  :: FX_RES2   = ZMM8r8_t([0.2406339113576119e+00_dp,0.1826230998017470e+00_dp, &
                                                                                0.1398658818165224e+00_dp,0.7389081634774706e-01_dp, &
                                                                                0.4015643112819418e-01_dp,0.2223939292592383e-01_dp, &
                                                                                0.1248349888726843e-01_dp,0.7078094908968090e-02_dp])
             
             type(ZMM8r8_t),                automatic  :: actual_zmm8r8
             type(Mask8_t),                 automatic  :: m_equal 
             real(kind=dp),                 automatic  :: actual_r8,sanity_r8,arg_r8,ref_r8   
#if 0
              integer(c_int),            parameter :: SIGTRAP = 5 
              integer(c_int),            automatic :: ret_val
#endif 
              integer(kind=i4),             automatic  :: i__ 
              integer(kind=i4),             automatic  :: fail_count 
              print*,  header
              !Sanity check of reference function 

              print*, "Sanity check of reference function."
              fail_count = 0
              do i__ = 1_i4, 20_i4 
                  arg_r8    = x_args(i__)
                  ref_r8    = fx_results(i__)
                  sanity_r8 = besk1(arg_r8)
                  if(ref_r8 .EqualTo. sanity_r8) then 
                     print*, "Floating-point compare #:",i__, "PASSED!!"
                     write(*,'(2x,g24.16,2x,g24.16)') sanity_r8, ref_r8 
                  else 
                     fail_count = fail_count+1_i4 
                     print*, "Floating-point compare #:",i__, "FAILED!!"
                     write(*,'(2x,g24.16,2x,g24.16)') sanity_r8, ref_r8 
                  end if 
              end do 
              if(fail_count .gt. 0_i4) then 
                 print*, "Detected: ", fail_count, "failed results!!"
                 !stop "ERRORS DETECTED!!"
              end if 

              m_equal.m = [.false.,.false.,.false.,.false., &
                           .false.,.false.,.false.,.false.]
              print *, "Starting main compute-comparison test."
#if 0
              ret_val =   raise(SIGTRAP)
               if(ret_val/=0_c_int) print*, "raise returned=",ret_val
#endif
              start         = rdtsc_wrap()
              actual_zmm8r8 = besk1_zmm8r8(X_ARG1)
              end           = rdtsc_wrap()
              m_equal       = zmm8r8_equalto_zmm8r8(actual_zmm8r8,FX_RES1)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG1-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG1-PASSED:] actual:",actual_zmm8r8,"expected=",FX_RES1
              else 
                 print*, "[X_ARG1-FAILED:] actual:",actual_zmm8r8,"expected=",FX_RES1
              endif
              start         = rdtsc_wrap()
              actual_zmm8r8 = besk1_zmm8r8(X_ARG2)
              end           = rdtsc_wrap()
              m_equal       = zmm8r8_equalto_zmm8r8(actual_zmm8r8,FX_RES2)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG2-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG2-PASSED:] actual:",actual_zmm8r8,"expected=",FX_RES2
              else 
                 print*, "[X_ARG2-FAILED:] actual:",actual_zmm8r8,"expected=",FX_RES2
              endif
                          
              print*, footer 
end subroutine unit_test_bessel_k1_zmm8r8





end module mod_test_bessel_k1_zmm8r8


program main 
    use mod_test_bessel_k1_zmm8r8
    call unit_test_bessel_k1_zmm8r8()
end program main 