

!/*MIT License
!Copyright (c) 2020 Bernard Gingold
!Permission is hereby granted, free of charge, to any person obtaining a copy
!of this software and associated documentation files (the "Software"), to deal
!in the Software without restriction, including without limitation the rights
!to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
!copies of the Software, and to permit persons to whom the Software is
!furnished to do so, subject to the following conditions:
!The above copyright notice and this permission notice shall be included in all
!copies or substantial portions of the Software.
!THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
!IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
!FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
!AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
!LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
!OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
!SOFTWARE.
!*/

module mod_test_bessel_i0_values


       use mod_kinds,     only : i4, dp 
       use mod_vectypes,  only : YMM4r8_t, Mask4_t
       use iso_c_binding, only : c_int, c_long_long 
     

       integer(kind=c_long_long),       parameter :: RDTSC_LATENCY = 18 ! for Skylake arch.
       integer(kind=c_long_long),       parameter :: ZERO          = 0_c_long_long 

#if 0
    ICC and ifort commands
    icc -c -std=c99 GMS_intrinsics_wrappers.c
    ifort -o test_bessel_i0_ymm4r8 -fp-model fast=2 -ftz -O3 -ggdb  -march=skylake-av512 \
    -fopenmp -qopenmp -fpp -falign-functions=32 -qopt-report=5 GMS_config.fpp GMS_kinds.f90 GMS_vectypes.f90 GMS_spec_func_ymm4r8.f90 GMS_mod_fpcompare.f90 GMS_intrinsics_wrappers.o unit_test_bessel_i0_ymm4r8.f90
    
    -------------------------------------------------------------------------------------------------------------------------------------------------
    For assembly only:
    ifort -S test_bessel_i0_values_ymm4r8 -fp-model fast=2 -ftz -O3 -ggdb  -march=skylake-avx512 \
     -fopenmp -qopenmp -fpp -falign-functions=32 -qopt-report=5 GMS_config.fpp GMS_kinds.f90 GMS_vectypes.f90 GMS_spec_func_ymm4r8.f90 \ 
      GMS_intrinsics_wrappers.o test_bessel_i0_values_ymm4r8.f90
#endif

      
      contains 

! Reference subroutines 
  function besi0 ( x )

!*****************************************************************************80
!
!! BESI0 evaluates the Bessel I0(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for
!    modified Bessel functions of the first kind of order zero for
!    arguments ABS(ARG) <= XMAX.
!
!    See comments heading CALCI0.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the argument of the function.
!
!    Output, real ( kind = 8 ) BESI0, the value of the function.
!
  implicit none

  real ( kind = 8 ) besi0
  integer ( kind = 4 ) jint
  real ( kind = 8 ) result
  real ( kind = 8 ) x

  jint = 1
  call calci0 ( x, result, jint )
  besi0 = result

  return
end

subroutine calci0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCI0 computes various I0 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the first kind
!    and order zero, I0(X) and EXP(-ABS(X))*I0(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of
!    minimax approximations generated by Blair and Edwards, Chalk
!    River (Atomic Energy of Canada Limited) Report AECL-4928,
!    October, 1974.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) ARG, the argument.  If JINT = 1, then
!    the argument must be less than XMAX.
!
!    Output, real ( kind = 8 ) RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = I0(x);
!    2, RESULT = exp(-x) * I0(x);
!
!    Input, integer ( kind = 4 ) JINT, chooses the function to be computed.
!    1, I0(x);
!    2, exp(-x) * I0(x);
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) arg
  real ( kind = 8 ) b
  real ( kind = 8 ) exp40
  real ( kind = 8 ) forty
  integer ( kind = 4 ) i
  integer ( kind = 4 ) jint
  real ( kind = 8 ) one
  real ( kind = 8 ) one5
  real ( kind = 8 ) p(15)
  real ( kind = 8 ) pp(8)
  real ( kind = 8 ) q(5)
  real ( kind = 8 ) qq(7)
  real ( kind = 8 ) result
  real ( kind = 8 ) rec15
  real ( kind = 8 ) sump
  real ( kind = 8 ) sumq
  real ( kind = 8 ) two25
  real ( kind = 8 ) x
  real ( kind = 8 ) xinf
  real ( kind = 8 ) xmax
  real ( kind = 8 ) xsmall
  real ( kind = 8 ) xx
!
!  Mathematical constants
!
  data one /1.0d0/
  data one5 /15.0d0/
  data exp40 /2.353852668370199854d17/
  data forty /40.0d0/
  data rec15 /6.6666666666666666666d-2/
  data two25 /225.0d0/
!
!  Machine-dependent constants
!
  data xsmall /5.55d-17/
  data xinf /1.79d308/
  data xmax /713.986d0/
!
!  Coefficients for XSMALL <= ABS(ARG) < 15.0
!
  data  p/-5.2487866627945699800d-18,-1.5982226675653184646d-14, &
          -2.6843448573468483278d-11,-3.0517226450451067446d-08, &
          -2.5172644670688975051d-05,-1.5453977791786851041d-02, &
          -7.0935347449210549190d+00,-2.4125195876041896775d+03, &
          -5.9545626019847898221d+05,-1.0313066708737980747d+08, &
          -1.1912746104985237192d+10,-8.4925101247114157499d+11, &
          -3.2940087627407749166d+13,-5.5050369673018427753d+14, &
          -2.2335582639474375249d+15/
  data  q/-3.7277560179962773046d+03, 6.5158506418655165707d+06, &
          -6.5626560740833869295d+09, 3.7604188704092954661d+12, &
          -9.7087946179594019126d+14/
!
!  Coefficients for 15.0 <= ABS(ARG)
!
  data pp/-3.9843750000000000000d-01, 2.9205384596336793945d+00, &
          -2.4708469169133954315d+00, 4.7914889422856814203d-01, &
          -3.7384991926068969150d-03,-2.6801520353328635310d-03, &
           9.9168777670983678974d-05,-2.1877128189032726730d-06/
  data qq/-3.1446690275135491500d+01, 8.5539563258012929600d+01, &
          -6.0228002066743340583d+01, 1.3982595353892851542d+01, &
          -1.1151759188741312645d+00, 3.2547697594819615062d-02, &
          -5.5194330231005480228d-04/

  x = abs ( arg )

  if ( x < xsmall ) then

    result = one
!
!  XSMALL <= ABS(ARG) < 15.0.
!
  else if ( x < one5 ) then

    xx = x * x
    sump = p(1)
    do i = 2, 15
      sump = sump * xx + p(i)
    end do
    xx = xx - two25

    sumq = (((( &
        xx + q(1) ) &
      * xx + q(2) ) &
      * xx + q(3) ) &
      * xx + q(4) ) &
      * xx + q(5)

    result = sump / sumq

    if ( jint == 2 ) then
      result = result * exp ( - x )
    end if

  else if ( one5 <= x ) then

    if ( jint == 1 .and. xmax < x ) then
      result = xinf
    else
!
!  15.0 <= ABS(ARG).
!
      xx = one / x - rec15

      sump = (((((( &
               pp(1) &
        * xx + pp(2) ) &
        * xx + pp(3) ) &
        * xx + pp(4) ) &
        * xx + pp(5) ) &
        * xx + pp(6) ) &
        * xx + pp(7) ) &
        * xx + pp(8)

      sumq = (((((( &
          xx + qq(1) ) &
        * xx + qq(2) ) &
        * xx + qq(3) ) &
        * xx + qq(4) ) &
        * xx + qq(5) ) &
        * xx + qq(6) ) &
        * xx + qq(7)

      result = sump / sumq

      if ( jint == 2 ) then
        result = ( result - pp(1) ) / sqrt ( x )
      else
!
!  Calculation reformulated to avoid premature overflow.
!
        if ( x .le.( xmax - one5 ) ) then
          a = exp ( x )
          b = one
        else
          a = exp ( x - forty )
          b = exp40
        end if

        result = ( ( result * a - pp(1) * a ) / sqrt ( x ) ) * b

      end if

    end if

  end if

  return
end


subroutine unit_test_bessel_i0_values()
           use spec_func_ymm4r8, only : besi0_ymm4r8, calci0_ymm4r8
           use mod_fpcompare 
           use iso_c_binding, only : c_int, c_long_long 
           use IFPORT 
           !use , intrinsic           :: IEEE_ARITHMETIC
           implicit none 
#if 0
              interface
                  function raise(sig) bind(C,name="raise")
                           use iso_c_binding, only : c_int 
                           integer(c_int) :: raise 
                           integer(c_int), value :: sig 
                  end function raise 
              end interface
#endif
              interface 
                   function rdtsc_wrap() bind(C,name="rdtsc_wrap")
                            use iso_c_binding, only : c_long_long 
                            integer(c_long_long) :: rdtsc_wrap 
                    end function rdtsc_wrap 
              end interface
              character(len=60),           parameter  :: header = "[TEST #1:  besi0_ymm4r8 -- START]"
              character(len=60),           parameter  :: footer = "[TEST #1:  besi0_ymm4r8 -- END]"
              integer(kind=c_long_long),   automatic  :: start, end 
              integer(kind=c_long_long),   automatic  :: start_c, end_c,tsc_elapsed
              real(kind=dp),dimension(20), parameter  :: x_args     = [&
                                                                   0.00E+00_dp, &
                                                                   0.20E+00_dp, &
                                                                   0.40E+00_dp, &
                                                                   0.60E+00_dp, &
                                                                   0.80E+00_dp, &
                                                                   0.10E+01_dp, &
                                                                   0.12E+01_dp, &
                                                                   0.14E+01_dp, &
                                                                   0.16E+01_dp, &
                                                                   0.18E+01_dp, &
                                                                   0.20E+01_dp, &
                                                                   0.25E+01_dp, &
                                                                   0.30E+01_dp, &
                                                                   0.35E+01_dp, &
                                                                   0.40E+01_dp, &
                                                                   0.45E+01_dp, &
                                                                   0.50E+01_dp, &
                                                                   0.60E+01_dp, &
                                                                   0.80E+01_dp, &
                                                                   0.10E+02_dp ]
              real(kind=dp),dimension(20), parameter  :: fx_results = [&
                                                                   0.1000000000000000E+01_dp, &
                                                                   0.1010025027795146E+01_dp, &
                                                                   0.1040401782229341E+01_dp, &
                                                                   0.1092045364317340E+01_dp, &
                                                                   0.1166514922869803E+01_dp, &
                                                                   0.1266065877752008E+01_dp, &
                                                                   0.1393725584134064E+01_dp, &
                                                                   0.1553395099731217E+01_dp, &
                                                                   0.1749980639738909E+01_dp, &
                                                                   0.1989559356618051E+01_dp, &
                                                                   0.2279585302336067E+01_dp, &
                                                                   0.3289839144050123E+01_dp, &
                                                                   0.4880792585865024E+01_dp, &
                                                                   0.7378203432225480E+01_dp, &
                                                                   0.1130192195213633E+02_dp, &
                                                                   0.1748117185560928E+02_dp, &
                                                                   0.2723987182360445E+02_dp, &
                                                                   0.6723440697647798E+02_dp, &
                                                                   0.4275641157218048E+03_dp, &
                                                                   0.2815716628466254E+04_dp ] 
             type(YMM4r8_t),                parameter  :: X_ARG1    = YMM4r8_t([0.0E+00_dp,0.20E+00_dp,0.40E+00_dp,0.60E+00_dp])
             type(YMM4r8_t),                parameter  :: X_ARG2    = YMM4r8_t([0.80E+00_dp,0.10E+01_dp,0.12E+01_dp,0.14E+01_dp])
             type(YMM4r8_t),                parameter  :: X_ARG3    = YMM4r8_t([0.16E+01_dp,0.18E+01_dp,0.20E+01_dp,0.25E+01_dp])
             type(YMM4r8_t),                parameter  :: X_ARG4    = YMM4r8_t([0.30E+01_dp,0.35E+01_dp,0.40E+01_dp,0.45E+01_dp])
             type(YMM4r8_t),                parameter  :: X_ARG5    = YMM4r8_t([0.50E+01_dp,0.60E+01_dp,0.80E+01_dp,0.10E+02_dp])
                         
             type(YMM4r8_t),                parameter  :: FX_RES1   = YMM4r8_t([0.1000000000000000E+01_dp,0.1010025027795146E+01_dp,&
                                                                                0.1040401782229341E+01_dp,0.1092045364317340E+01_dp])
             type(YMM4r8_t),                parameter  :: FX_RES2   = YMM4r8_t([0.1166514922869803E+01_dp,0.1266065877752008E+01_dp, &
                                                                                0.1393725584134064E+01_dp,0.1553395099731217E+01_dp])
             type(YMM4r8_t),                parameter  :: FX_RES3   = YMM4r8_t([0.1749980639738909E+01_dp,0.1989559356618051E+01_dp, &
                                                                                0.2279585302336067E+01_dp,0.3289839144050123E+01_dp])
             type(YMM4r8_t),                parameter  :: FX_RES4   = YMM4r8_t([0.4880792585865024E+01_dp,0.7378203432225480E+01_dp, &
                                                                                0.1130192195213633E+02_dp,0.1748117185560928E+02_dp])
             type(YMM4r8_t),                parameter  :: FX_RES5   = YMM4r8_t([0.2723987182360445E+02_dp,0.6723440697647798E+02_dp, &
                                                                                0.4275641157218048E+03_dp,0.2815716628466254E+04_dp])
             type(YMM4r8_t),                automatic  :: actual_ymm4r8
             type(Mask4_t),                 automatic  :: m_equal 
             real(kind=dp),                 automatic  :: actual_r8,sanity_r8,arg_r8,ref_r8   
#if 0
              integer(c_int),            parameter :: SIGTRAP = 5 
              integer(c_int),            automatic :: ret_val
#endif 
              integer(kind=i4),             automatic  :: i__ 
              integer(kind=i4),             automatic  :: fail_count 
              print*,  header
              !Sanity check of reference function 

              print*, "Sanity check of reference function."
              fail_count = 0
              do i__ = 1_i4, 20_i4 
                  arg_r8    = x_args(i__)
                  ref_r8    = fx_results(i__)
                  sanity_r8 = besi0(arg_r8)
                  if(ref_r8 .EqualTo. sanity_r8) then 
                     print*, "Floating-point compare #:",i__, "PASSED!!"
                     write(*,'(2x,g24.16,2x,g24.16)') sanity_r8, ref_r8 
                  else 
                     fail_count = fail_count+1_i4 
                     print*, "Floating-point compare #:",i__, "FAILED!!"
                     write(*,'(2x,g24.16,2x,g24.16)') sanity_r8, ref_r8 
                  end if 
              end do 
              if(fail_count .gt. 0_i4) then 
                 print*, "Detected: ", fail_count, "failed results!!"
                 !stop "ERRORS DETECTED!!"
              end if 

              m_equal.m = [.false.,.false.,.false.,.false.]
              print *, "Starting main compute-comparison test."
#if 0
              ret_val =   raise(SIGTRAP)
               if(ret_val/=0_c_int) print*, "raise returned=",ret_val
#endif
              start         = rdtsc_wrap()
              actual_ymm4r8 = besi0_ymm4r8(X_ARG1)
              end           = rdtsc_wrap()
              m_equal       = ymm4r8_equalto_ymm4r8(actual_ymm4r8,FX_RES1)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG1-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG1-PASSED:] actual:",actual_ymm4r8,"expected=",FX_RES1
              else 
                 print*, "[X_ARG1-FAILED:] actual:",actual_ymm4r8,"expected=",FX_RES1
              endif
              start         = rdtsc_wrap()
              actual_ymm4r8 = besi0_ymm4r8(X_ARG2)
              end           = rdtsc_wrap()
              m_equal       = ymm4r8_equalto_ymm4r8(actual_ymm4r8,FX_RES2)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG2-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG2-PASSED:] actual:",actual_ymm4r8,"expected=",FX_RES2
              else 
                 print*, "[X_ARG2-FAILED:] actual:",actual_ymm4r8,"expected=",FX_RES2
              endif
              start         = rdtsc_wrap()
              actual_ymm4r8 = besi0_ymm4r8(X_ARG3)
              end           = rdtsc_wrap()
              m_equal       = ymm4r8_equalto_ymm4r8(actual_ymm4r8,FX_RES3)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG3-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG3-PASSED:] actual:",actual_ymm4r8,"expected=",FX_RES3
              else 
                 print*, "[X_ARG3-FAILED:] actual:",actual_ymm4r8,"expected=",FX_RES3
              endif
              start         = rdtsc_wrap()
              actual_ymm4r8 = besi0_ymm4r8(X_ARG4)
              end           = rdtsc_wrap()
              m_equal       = ymm4r8_equalto_ymm4r8(actual_ymm4r8,FX_RES4)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG4-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG4-PASSED:] actual:",actual_ymm4r8,"expected=",FX_RES4
              else 
                 print*, "[X_ARG4-FAILED:] actual:",actual_ymm4r8,"expected=",FX_RES4
              endif
              start         = rdtsc_wrap()
              actual_ymm4r8 = besi0_ymm4r8(X_ARG5)
              end           = rdtsc_wrap()
              m_equal       = ymm4r8_equalto_ymm4r8(actual_ymm4r8,FX_RES5)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG5-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG5-PASSED:] actual:",actual_ymm4r8,"expected=",FX_RES5
              else 
                 print*, "[X_ARG5-FAILED:] actual:",actual_ymm4r8,"expected=",FX_RES5
              endif
             
              print*, footer 
end subroutine unit_test_bessel_i0_values


end module mod_test_bessel_i0_values



program main 
   use mod_test_bessel_i0_values
   call unit_test_bessel_i0_values()
end program main 