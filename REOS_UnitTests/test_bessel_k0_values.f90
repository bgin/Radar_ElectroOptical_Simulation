
!/*MIT License
!Copyright (c) 2020 Bernard Gingold
!Permission is hereby granted, free of charge, to any person obtaining a copy
!of this software and associated documentation files (the "Software"), to deal
!in the Software without restriction, including without limitation the rights
!to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
!copies of the Software, and to permit persons to whom the Software is
!furnished to do so, subject to the following conditions:
!The above copyright notice and this permission notice shall be included in all
!copies or substantial portions of the Software.
!THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
!IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
!FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
!AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
!LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
!OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
!SOFTWARE.
!*/

module mod_test_bessel_k0_values


       use mod_kinds,     only : i4, dp 
       use mod_vectypes,  only : XMM2r8_t, Mask2_t
       use iso_c_binding, only : c_int, c_long_long 
     

       integer(kind=c_long_long),       parameter :: RDTSC_LATENCY = 18 ! for Skylake arch.
       integer(kind=c_long_long),       parameter :: ZERO          = 0_c_long_long 

#if 0
    ICC and ifort commands
    icc -c -std=c99 GMS_intrinsics_wrappers.c
    ifort -o test_bessel_k0_values -fp-model fast=2 -ftz -O3 -ggdb  -xHost \
    -fopenmp -qopenmp -fpp -falign-functions=32 -qopt-report=5 GMS_config.fpp GMS_kinds.f90 GMS_vectypes.f90 GMS_spec_func_xmm2r8.f90 GMS_mod_fpcompare.f90 GMS_intrinsics_wrappers.o test_bessel_k0_values.f90
    
    -------------------------------------------------------------------------------------------------------------------------------------------------
    For assembly only:
    ifort -S -fp-model fast=2 -ftz -O3 -ggdb  -xHost \
     -fopenmp -qopenmp -fpp -falign-functions=32 -qopt-report=5 GMS_config.fpp GMS_kinds.f90 GMS_vectypes.f90 GMS_spec_funcs_xmm2r8.f90 GMS_mod_fpcompare.f90 GMS_intrinsics_wrappers.o test_bessel_i1_values.f90
      
#endif

      contains 

function besk0 ( x )

!*****************************************************************************80
!
!! BESK0 evaluates the Bessel K0(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for the
!    modified Bessel function of the second kind of order zero
!    for arguments 0.0 < ARG <= XMAX.
!
!    See comments heading CALCK0.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the argument of the function.
!
!    Output, real ( kind = 8 ) BESK0, the value of the function.
!
  implicit none

  real ( kind = 8 ) besk0
  integer ( kind = 4 ) jint
  real ( kind = 8 ) result
  real ( kind = 8 ) x

  jint = 1
  call calck0 ( x, result, jint )
  besk0 = result

  return
end function 

subroutine calck0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCK0 computes various K0 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the second kind
!    and order zero, K0(X) and EXP(X)*K0(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of near
!    minimax rational approximations generated by Russon and Blair,
!    Chalk River (Atomic Energy of Canada Limited) Report AECL-3461,
!    1969.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) ARG, the argument.  0 < ARG is
!    always required.  If JINT = 1, then the argument must also be
!    less than XMAX.
!
!    Output, real ( kind = 8 ) RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = K0(x);
!    2, RESULT = exp(x) * K0(x);
!
!    Input, integer ( kind = 4 ) JINT, chooses the function to be computed.
!    1, K0(x);
!    2, exp(x) * K0(x);
!
  implicit none

  integer ( kind = 4 ) i
  integer ( kind = 4 ) jint
  real ( kind = 8 ) arg
  real ( kind = 8 ) f(4)
  real ( kind = 8 ) g(3)
  real ( kind = 8 ) one
  real ( kind = 8 ) p(6)
  real ( kind = 8 ) pp(10)
  real ( kind = 8 ) q(2)
  real ( kind = 8 ) qq(10)
  real ( kind = 8 ) result
  real ( kind = 8 ) sumf
  real ( kind = 8 ) sumg
  real ( kind = 8 ) sump
  real ( kind = 8 ) sumq
  real ( kind = 8 ) temp
  real ( kind = 8 ) x
  real ( kind = 8 ) xinf
  real ( kind = 8 ) xmax
  real ( kind = 8 ) xsmall
  real ( kind = 8 ) xx
  real ( kind = 8 ) zero
!
!  Mathematical constants
!
  data one /1.0d0/
  data zero /0.0d0/
!
!  Machine-dependent constants
!
  data xsmall /1.11d-16/
  data xinf /1.79d+308/
  data xmax /705.342d0/
!
!  Coefficients for XSMALL <= ARG <= 1.0
!
  data   p/ 5.8599221412826100000d-04, 1.3166052564989571850d-01, &
            1.1999463724910714109d+01, 4.6850901201934832188d+02, &
            5.9169059852270512312d+03, 2.4708152720399552679d+03/
  data   q/-2.4994418972832303646d+02, 2.1312714303849120380d+04/
  data   f/-1.6414452837299064100d+00,-2.9601657892958843866d+02, &
           -1.7733784684952985886d+04,-4.0320340761145482298d+05/
  data   g/-2.5064972445877992730d+02, 2.9865713163054025489d+04, &
           -1.6128136304458193998d+06/
!
!  Coefficients for  1.0 < ARG
!
  data  pp/ 1.1394980557384778174d+02, 3.6832589957340267940d+03, &
            3.1075408980684392399d+04, 1.0577068948034021957d+05, &
            1.7398867902565686251d+05, 1.5097646353289914539d+05, &
            7.1557062783764037541d+04, 1.8321525870183537725d+04, &
            2.3444738764199315021d+03, 1.1600249425076035558d+02/
  data  qq/ 2.0013443064949242491d+02, 4.4329628889746408858d+03, &
            3.1474655750295278825d+04, 9.7418829762268075784d+04, &
            1.5144644673520157801d+05, 1.2689839587977598727d+05, &
            5.8824616785857027752d+04, 1.4847228371802360957d+04, &
            1.8821890840982713696d+03, 9.2556599177304839811d+01/

  x = arg
!
!  0.0 < ARG <= 1.0.
!
  if ( zero < x ) then

    if ( x <= one ) then

      temp = log ( x )

      if ( x < xsmall ) then
!
!  Return for small ARG.
!
        result = p(6) / q(2) - temp

      else

        xx = x * x

        sump = (((( &
                 p(1) &
          * xx + p(2) ) &
          * xx + p(3) ) &
          * xx + p(4) ) &
          * xx + p(5) ) &
          * xx + p(6)

        sumq = ( xx + q(1) ) * xx + q(2)
        sumf = ( ( &
                 f(1) &
          * xx + f(2) ) &
          * xx + f(3) ) &
          * xx + f(4)

        sumg = ( ( xx + g(1) ) * xx + g(2) ) * xx + g(3)

        result = sump / sumq - xx * sumf * temp / sumg - temp

        if ( jint == 2 ) then
          result = result * exp ( x )
        end if

      end if

    else if ( jint == 1 .and. xmax < x ) then
!
!  Error return for XMAX < ARG.
!
      result = zero

    else
!
!  1.0 < ARG.
!
      xx = one / x
      sump = pp(1)
      do i = 2, 10
        sump = sump * xx + pp(i)
      end do

      sumq = xx
      do i = 1, 9
        sumq = ( sumq + qq(i) ) * xx
      end do
      sumq = sumq + qq(10)
      result = sump / sumq / sqrt ( x )

      if ( jint == 1 ) then
        result = result * exp ( -x )
      end if

    end if

  else
!
!  Error return for ARG <= 0.0.
!
    result = xinf

  end if

  return
end subroutine 


subroutine unit_test_bessel_k0_values()
           use spec_func_xmm2r8, only : besk0_xmm2r8, calck0_xmm2r8
           use mod_fpcompare 
           use iso_c_binding, only : c_int, c_long_long 
           use IFPORT 
           !use , intrinsic           :: IEEE_ARITHMETIC
           implicit none 
#if 0
              interface
                  function raise(sig) bind(C,name="raise")
                           use iso_c_binding, only : c_int 
                           integer(c_int) :: raise 
                           integer(c_int), value :: sig 
                  end function raise 
              end interface
#endif
              interface 
                   function rdtsc_wrap() bind(C,name="rdtsc_wrap")
                            use iso_c_binding, only : c_long_long 
                            integer(c_long_long) :: rdtsc_wrap 
                    end function rdtsc_wrap 
              end interface
              character(len=60),           parameter  :: header = "[TEST #1:  besk0_xmm2r8 -- START]"
              character(len=60),           parameter  :: footer = "[TEST #1:  besk0_xmm2r8 -- END]"
              integer(kind=c_long_long),   automatic  :: start, end 
              integer(kind=c_long_long),   automatic  :: start_c, end_c,tsc_elapsed
              real(kind=dp),dimension(20), parameter  :: x_args     = [&
                                                                     0.1e+00_dp, &
                                                                     0.2e+00_dp, &
                                                                     0.4e+00_dp, &
                                                                     0.6e+00_dp, &
                                                                     0.8e+00_dp, &
                                                                     1.0e+00_dp, &
                                                                     1.2e+00_dp, &
                                                                     1.4e+00_dp, &
                                                                     1.6e+00_dp, &
                                                                     1.8e+00_dp, &
                                                                     2.0e+00_dp, &
                                                                     2.5e+00_dp, &
                                                                     3.0e+00_dp, &
                                                                     3.5e+00_dp, &
                                                                     4.0e+00_dp, &
                                                                     4.5e+00_dp, &
                                                                     5.0e+00_dp, &
                                                                     6.0e+00_dp, &
                                                                     8.0e+00_dp, &
                                                                     10.0e+00_dp ]
              real(kind=dp),dimension(20), parameter  :: fx_results = [&
                                                                    0.2427069024702017e+01_dp, &
                                                                    0.1752703855528146e+01_dp, &
                                                                    0.1114529134524434e+01_dp, &
                                                                    0.7775220919047293e+00_dp, &
                                                                    0.5653471052658957e+00_dp, &
                                                                    0.4210244382407083e+00_dp, &
                                                                    0.3185082202865936e+00_dp, &
                                                                    0.2436550611815419e+00_dp, &
                                                                    0.1879547519693323e+00_dp, &
                                                                    0.1459314004898280e+00_dp, &
                                                                    0.1138938727495334e+00_dp, &
                                                                    0.6234755320036619e-01_dp, &
                                                                    0.3473950438627925e-01_dp, &
                                                                    0.1959889717036849e-01_dp, &
                                                                    0.1115967608585302e-01_dp, &
                                                                    0.6399857243233975e-02_dp, &
                                                                    0.3691098334042594e-02_dp, &
                                                                    0.1243994328013123e-02_dp, &
                                                                    0.1464707052228154e-03_dp, &
                                                                    0.1778006231616765e-04_dp] 
             type(XMM2r8_t),                parameter  :: X_ARG1    = XMM2r8_t([0.1E+00_dp,0.2E+00_dp])
             type(XMM2r8_t),                parameter  :: X_ARG2    = XMM2r8_t([0.4E+00_dp,0.6E+00_dp])
             type(XMM2r8_t),                parameter  :: X_ARG3    = XMM2r8_t([0.8E+00_dp,0.1E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG4    = XMM2r8_t([0.12E+01_dp,0.14E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG5    = XMM2r8_t([0.16E+01_dp,0.18E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG6    = XMM2r8_t([0.20E+01_dp,0.25E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG7    = XMM2r8_t([0.30E+01_dp,0.35E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG8    = XMM2r8_t([0.40E+01_dp,0.45E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG9    = XMM2r8_t([0.50E+01_dp,0.60E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG10   = XMM2r8_t([0.80E+01_dp,0.10E+02_dp])
             
             type(XMM2r8_t),                parameter  :: FX_RES1   = XMM2r8_t([0.2427069024702017e+01_dp,0.1752703855528146e+01_dp])
             type(XMM2r8_t),                parameter  :: FX_RES2   = XMM2r8_t([0.1114529134524434e+01_dp,0.7775220919047293e+00_dp])
             type(XMM2r8_t),                parameter  :: FX_RES3   = XMM2r8_t([0.5653471052658957e+00_dp,0.4210244382407083e+00_dp])
             type(XMM2r8_t),                parameter  :: FX_RES4   = XMM2r8_t([0.3185082202865936e+00_dp,0.2436550611815419e+00_dp])
             type(XMM2r8_t),                parameter  :: FX_RES5   = XMM2r8_t([0.1879547519693323e+00_dp,0.1459314004898280e+00_dp])
             type(XMM2r8_t),                parameter  :: FX_RES6   = XMM2r8_t([0.1138938727495334e+00_dp,0.6234755320036619e-01_dp])
             type(XMM2r8_t),                parameter  :: FX_RES7   = XMM2r8_t([0.3473950438627925e-01_dp,0.1959889717036849e-01_dp])
             type(XMM2r8_t),                parameter  :: FX_RES8   = XMM2r8_t([0.1115967608585302e-01_dp,0.6399857243233975e-02_dp])
             type(XMM2r8_t),                parameter  :: FX_RES9   = XMM2r8_t([0.3691098334042594e-02_dp,0.1243994328013123e-02_dp])
             type(XMM2r8_t),                parameter  :: FX_RES10  = XMM2r8_t([0.1464707052228154e-03_dp,0.1778006231616765e-04_dp])
             type(XMM2r8_t),                automatic  :: actual_xmm2r8
             type(Mask2_t),                 automatic  :: m_equal 
             real(kind=dp),                 automatic  :: actual_r8,sanity_r8,arg_r8,ref_r8   
#if 0
              integer(c_int),            parameter :: SIGTRAP = 5 
              integer(c_int),            automatic :: ret_val
#endif 
              integer(kind=i4),             automatic  :: i__ 
              integer(kind=i4),             automatic  :: fail_count 
              print*,  header
              !Sanity check of reference function 

              print*, "Sanity check of reference function."
              fail_count = 0
              do i__ = 1_i4, 20_i4 
                  arg_r8    = x_args(i__)
                  ref_r8    = fx_results(i__)
                  sanity_r8 = besk0(arg_r8)
                  if(ref_r8 .EqualTo. sanity_r8) then 
                     print*, "Floating-point compare #:",i__, "PASSED!!"
                     write(*,'(2x,g24.16,2x,g24.16)') sanity_r8, ref_r8 
                  else 
                     fail_count = fail_count+1_i4 
                     print*, "Floating-point compare #:",i__, "FAILED!!"
                     write(*,'(2x,g24.16,2x,g24.16)') sanity_r8, ref_r8 
                  end if 
              end do 
              if(fail_count .gt. 0_i4) then 
                 print*, "Detected: ", fail_count, "failed results!!"
                 !stop "ERRORS DETECTED!!"
              end if 

              m_equal.m = [.false.,.false.]
              print *, "Starting main compute-comparison test."
#if 0
              ret_val =   raise(SIGTRAP)
               if(ret_val/=0_c_int) print*, "raise returned=",ret_val
#endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG1)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES1)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG1-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG1-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES1
              else 
                 print*, "[X_ARG1-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES1
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG2)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES2)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG2-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG2-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES2
              else 
                 print*, "[X_ARG2-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES2
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG3)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES2)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG3-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG3-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES3
              else 
                 print*, "[X_ARG3-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES3
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG4)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES4)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG4-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG4-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES4
              else 
                 print*, "[X_ARG4-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES4
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG5)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES5)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG5-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG5-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES5
              else 
                 print*, "[X_ARG5-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES5
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG6)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES6)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG6-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG6-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES6
              else 
                 print*, "[X_ARG6-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES6
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG7)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES7)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG7-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG7-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES7
              else 
                 print*, "[X_ARG7-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES7
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG8)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES8)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG8-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG8-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES8
              else 
                 print*, "[X_ARG8-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES8
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG9)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES9)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG1-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG9-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES9
              else 
                 print*, "[X_ARG9-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES9
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besk0_xmm2r8(X_ARG10)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES10)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG10-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG10-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES10
              else 
                 print*, "[X_ARG10-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES10
              endif
              print*, footer 
end subroutine unit_test_bessel_k0_values





end module mod_test_bessel_k0_values


program main 
    use mod_test_bessel_k0_values
    call unit_test_bessel_k0_values()
end program main 