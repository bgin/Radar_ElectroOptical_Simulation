
!/*MIT License
!Copyright (c) 2020 Bernard Gingold
!Permission is hereby granted, free of charge, to any person obtaining a copy
!of this software and associated documentation files (the "Software"), to deal
!in the Software without restriction, including without limitation the rights
!to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
!copies of the Software, and to permit persons to whom the Software is
!furnished to do so, subject to the following conditions:
!The above copyright notice and this permission notice shall be included in all
!copies or substantial portions of the Software.
!THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
!IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
!FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
!AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
!LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
!OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
!SOFTWARE.
!*/

module mod_test_bessel_i1_values


       use mod_kinds,     only : i4, dp 
       use mod_vectypes,  only : XMM2r8_t, Mask2_t
       use iso_c_binding, only : c_int, c_long_long 
     

       integer(kind=c_long_long),       parameter :: RDTSC_LATENCY = 18 ! for Skylake arch.
       integer(kind=c_long_long),       parameter :: ZERO          = 0_c_long_long 

#if 0
    ICC and ifort commands
    icc -c -std=c99 GMS_intrinsics_wrappers.c
    ifort -o test_bessel_i1_values -fp-model fast=2 -ftz -O3 -ggdb  -xHost \
    -fopenmp -qopenmp -fpp -falign-functions=32 -qopt-report=5 GMS_config.fpp GMS_kinds.f90 GMS_vectypes.f90 GMS_spec_func_xmm2r8.f90 GMS_mod_fpcompare.f90 GMS_intrinsics_wrappers.o test_bessel_i1_values.f90
    
    -------------------------------------------------------------------------------------------------------------------------------------------------
    For assembly only:
    ifort -S -fp-model fast=2 -ftz -O3 -ggdb  -xHost \
     -fopenmp -qopenmp -fpp -falign-functions=32 -qopt-report=5 GMS_config.fpp GMS_kinds.f90 GMS_vectypes.f90 GMS_spec_funcs_xmm2r8.f90 GMS_mod_fpcompare.f90 GMS_intrinsics_wrappers.o test_bessel_i1_values.f90
      
#endif

      contains 

function besi1 ( x )

!*****************************************************************************80
!
!! BESI1 evaluates the Bessel I1(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for
!    modified Bessel functions of the first kind of order one for
!    arguments ABS(ARG) <= XMAX.
!
!    See comments heading CALCI1.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the argument of the function.
!
!    Output, real ( kind = 8 ) BESI1, the value of the function.
!
  implicit none

  real ( kind = 8 ) besi1
  integer ( kind = 4 ) jint
  real ( kind = 8 ) result
  real ( kind = 8 ) x

  jint = 1
  call calci1 ( x, result, jint )
  besi1 = result

  return
end function besi1 

subroutine calci1 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCI1 computes various I1 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functioons of the first kind
!    and order one, I1(X) and EXP(-ABS(X))*I1(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of
!    minimax approximations generated by Blair and Edwards, Chalk
!    River (Atomic Energy of Canada Limited) Report AECL-4928,
!    October, 1974.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) ARG, the argument.  If JINT = 1, then
!    the argument must be less than XMAX.
!
!    Output, real ( kind = 8 ) RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = I1(x);
!    2, RESULT = exp(-x) * I1(x);
!
!    Input, integer ( kind = 4 ) JINT, chooses the function to be computed.
!    1, I1(x);
!    2, exp(-x) * I1(x);
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) arg
  real ( kind = 8 ) b
  real ( kind = 8 ) exp40
  real ( kind = 8 ) forty
  real ( kind = 8 ) half
  integer ( kind = 4 ) j
  integer ( kind = 4 ) jint
  real ( kind = 8 ) one
  real ( kind = 8 ) one5
  real ( kind = 8 ) p(15)
  real ( kind = 8 ) pbar
  real ( kind = 8 ) pp(8)
  real ( kind = 8 ) q(5)
  real ( kind = 8 ) qq(6)
  real ( kind = 8 ) rec15
  real ( kind = 8 ) result
  real ( kind = 8 ) sump
  real ( kind = 8 ) sumq
  real ( kind = 8 ) two25
  real ( kind = 8 ) x
  real ( kind = 8 ) xinf
  real ( kind = 8 ) xmax
  real ( kind = 8 ) xsmall
  real ( kind = 8 ) xx
  real ( kind = 8 ) zero
!
!  Mathematical constants
!
  data one /1.0d0/
  data one5 /15.0d0/
  data exp40 /2.353852668370199854d17/
  data forty /40.0d0/
  data rec15 /6.6666666666666666666d-2/
  data two25 /225.0d0/
  data half /0.5d0/
  data zero /0.0d0/
!
!  Machine-dependent constants
!
  data xsmall /5.55d-17/
  data xinf /1.79d308/
  data xmax /713.987d0/
!
!  Coefficients for XSMALL <= ABS(ARG) < 15.0
!
  data p/-1.9705291802535139930d-19,-6.5245515583151902910d-16, &
         -1.1928788903603238754d-12,-1.4831904935994647675d-09, &
         -1.3466829827635152875d-06,-9.1746443287817501309d-04, &
         -4.7207090827310162436d-01,-1.8225946631657315931d+02, &
         -5.1894091982308017540d+04,-1.0588550724769347106d+07, &
         -1.4828267606612366099d+09,-1.3357437682275493024d+11, &
         -6.9876779648010090070d+12,-1.7732037840791591320d+14, &
         -1.4577180278143463643d+15/
  data q/-4.0076864679904189921d+03, 7.4810580356655069138d+06, &
         -8.0059518998619764991d+09, 4.8544714258273622913d+12, &
         -1.3218168307321442305d+15/
!
!  Coefficients for 15.0 <= ABS(ARG)
!
  data pp/-6.0437159056137600000d-02, 4.5748122901933459000d-01, &
          -4.2843766903304806403d-01, 9.7356000150886612134d-02, &
          -3.2457723974465568321d-03,-3.6395264712121795296d-04, &
           1.6258661867440836395d-05,-3.6347578404608223492d-07/
  data qq/-3.8806586721556593450d+00, 3.2593714889036996297d+00, &
          -8.5017476463217924408d-01, 7.4212010813186530069d-02, &
          -2.2835624489492512649d-03, 3.7510433111922824643d-05/
  data pbar/3.98437500d-01/

  x = abs ( arg )
!
!  Return for ABS(ARG) < XSMALL.
!
  if ( x < xsmall ) then

    result = half * x
!
!  XSMALL <= ABS(ARG) < 15.0.
!
  else if ( x < one5 ) then

    xx = x * x
    sump = p(1)
    do j = 2, 15
      sump = sump * xx + p(j)
    end do
    xx = xx - two25

    sumq = (((( &
        xx + q(1) ) &
      * xx + q(2) ) &
      * xx + q(3) ) &
      * xx + q(4) ) &
      * xx + q(5)

    result = ( sump / sumq ) * x

    if ( jint == 2 ) then
      result = result * exp ( -x )
    end if

  else if ( jint == 1 .and. xmax < x ) then

    result = xinf

  else
!
!  15.0 <= ABS(ARG).
!
    xx = one / x - rec15

    sump = (((((( &
             pp(1) &
      * xx + pp(2) ) &
      * xx + pp(3) ) &
      * xx + pp(4) ) &
      * xx + pp(5) ) &
      * xx + pp(6) ) &
      * xx + pp(7) ) &
      * xx + pp(8)

    sumq = ((((( &
        xx + qq(1) ) &
      * xx + qq(2) ) &
      * xx + qq(3) ) &
      * xx + qq(4) ) &
      * xx + qq(5) ) &
      * xx + qq(6)

    result = sump / sumq

    if ( jint /= 1 ) then
      result = ( result + pbar ) / sqrt ( x )
    else
!
!  Calculation reformulated to avoid premature overflow.
!
      if ( xmax - one5 < x ) then
        a = exp ( x - forty )
        b = exp40
      else
        a = exp ( x )
        b = one
      end if

      result = ( ( result * a + pbar * a ) / sqrt ( x ) ) * b

    end if
  end if

  if ( arg < zero ) then
    result = -result
  end if

  return
end subroutine calci1 


subroutine unit_test_bessel_i1_values()
           use spec_func_xmm2r8, only : besi1_xmm2r8, calci1_xmm2r8
           use mod_fpcompare 
           use iso_c_binding, only : c_int, c_long_long 
           use IFPORT 
           !use , intrinsic           :: IEEE_ARITHMETIC
           implicit none 
#if 0
              interface
                  function raise(sig) bind(C,name="raise")
                           use iso_c_binding, only : c_int 
                           integer(c_int) :: raise 
                           integer(c_int), value :: sig 
                  end function raise 
              end interface
#endif
              interface 
                   function rdtsc_wrap() bind(C,name="rdtsc_wrap")
                            use iso_c_binding, only : c_long_long 
                            integer(c_long_long) :: rdtsc_wrap 
                    end function rdtsc_wrap 
              end interface
              character(len=60),           parameter  :: header = "[TEST #1:  besseli1_xmm2r8 -- START]"
              character(len=60),           parameter  :: footer = "[TEST #1:  besseli1_xmm2r8 -- END]"
              integer(kind=c_long_long),   automatic  :: start, end 
              integer(kind=c_long_long),   automatic  :: start_c, end_c,tsc_elapsed
              real(kind=dp),dimension(20), parameter  :: x_args     = [&
                                                                   0.00E+00_dp, &
                                                                   0.20E+00_dp, &
                                                                   0.40E+00_dp, &
                                                                   0.60E+00_dp, &
                                                                   0.80E+00_dp, &
                                                                   0.10E+01_dp, &
                                                                   0.12E+01_dp, &
                                                                   0.14E+01_dp, &
                                                                   0.16E+01_dp, &
                                                                   0.18E+01_dp, &
                                                                   0.20E+01_dp, &
                                                                   0.25E+01_dp, &
                                                                   0.30E+01_dp, &
                                                                   0.35E+01_dp, &
                                                                   0.40E+01_dp, &
                                                                   0.45E+01_dp, &
                                                                   0.50E+01_dp, &
                                                                   0.60E+01_dp, &
                                                                   0.80E+01_dp, &
                                                                   0.10E+02_dp ]
              real(kind=dp),dimension(20), parameter  :: fx_results = [&
                                                                   0.0000000000000000E+00_dp, &
                                                                   0.1005008340281251E+00_dp, &
                                                                   0.2040267557335706E+00_dp, &
                                                                   0.3137040256049221E+00_dp, &
                                                                   0.4328648026206398E+00_dp, &
                                                                   0.5651591039924850E+00_dp, &
                                                                   0.7146779415526431E+00_dp, &
                                                                   0.8860919814143274E+00_dp, &
                                                                   0.1084810635129880E+01_dp, &
                                                                   0.1317167230391899E+01_dp, &
                                                                   0.1590636854637329E+01_dp, &
                                                                   0.2516716245288698E+01_dp, &
                                                                   0.3953370217402609E+01_dp, &
                                                                   0.6205834922258365E+01_dp, &
                                                                   0.9759465153704450E+01_dp, &
                                                                   0.1538922275373592E+02_dp, &
                                                                   0.2433564214245053E+02_dp, &
                                                                   0.6134193677764024E+02_dp, &
                                                                   0.3998731367825601E+03_dp, &
                                                                   0.2670988303701255E+04_dp  ] 
             type(XMM2r8_t),                parameter  :: X_ARG1    = XMM2r8_t([0.0E+00_dp,0.20E+00_dp])
             type(XMM2r8_t),                parameter  :: X_ARG2    = XMM2r8_t([0.40E+00_dp,0.60E+00_dp])
             type(XMM2r8_t),                parameter  :: X_ARG3    = XMM2r8_t([0.80E+00_dp,0.10E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG4    = XMM2r8_t([0.12E+01_dp,0.14E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG5    = XMM2r8_t([0.16E+01_dp,0.18E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG6    = XMM2r8_t([0.20E+01_dp,0.25E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG7    = XMM2r8_t([0.30E+01_dp,0.35E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG8    = XMM2r8_t([0.40E+01_dp,0.45E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG9    = XMM2r8_t([0.50E+01_dp,0.60E+01_dp])
             type(XMM2r8_t),                parameter  :: X_ARG10   = XMM2r8_t([0.80E+01_dp,0.10E+02_dp])
             
             type(XMM2r8_t),                parameter  :: FX_RES1   = XMM2r8_t([0.0000000000000000E+00_dp,0.1005008340281251E+00_dp])
             type(XMM2r8_t),                parameter  :: FX_RES2   = XMM2r8_t([0.2040267557335706E+00_dp,0.3137040256049221E+00_dp])
             type(XMM2r8_t),                parameter  :: FX_RES3   = XMM2r8_t([0.4328648026206398E+00_dp,0.5651591039924850E+00_dp])
             type(XMM2r8_t),                parameter  :: FX_RES4   = XMM2r8_t([0.7146779415526431E+00_dp,0.8860919814143274E+00_dp])
             type(XMM2r8_t),                parameter  :: FX_RES5   = XMM2r8_t([0.1084810635129880E+01_dp,0.1317167230391899E+01_dp])
             type(XMM2r8_t),                parameter  :: FX_RES6   = XMM2r8_t([0.1590636854637329E+01_dp,0.2516716245288698E+01_dp])
             type(XMM2r8_t),                parameter  :: FX_RES7   = XMM2r8_t([0.3953370217402609E+01_dp,0.6205834922258365E+01_dp])
             type(XMM2r8_t),                parameter  :: FX_RES8   = XMM2r8_t([0.9759465153704450E+01_dp,0.1538922275373592E+02_dp])
             type(XMM2r8_t),                parameter  :: FX_RES9   = XMM2r8_t([0.2433564214245053E+02_dp,0.6134193677764024E+02_dp])
             type(XMM2r8_t),                parameter  :: FX_RES10  = XMM2r8_t([0.3998731367825601E+03_dp,0.2670988303701255E+04_dp])
             type(XMM2r8_t),                automatic  :: actual_xmm2r8
             type(Mask2_t),                 automatic  :: m_equal 
             real(kind=dp),                 automatic  :: actual_r8,sanity_r8,arg_r8,ref_r8   
#if 0
              integer(c_int),            parameter :: SIGTRAP = 5 
              integer(c_int),            automatic :: ret_val
#endif 
              integer(kind=i4),             automatic  :: i__ 
              integer(kind=i4),             automatic  :: fail_count 
              print*,  header
              !Sanity check of reference function 

              print*, "Sanity check of reference function."
              fail_count = 0
              do i__ = 1_i4, 20_i4 
                  arg_r8    = x_args(i__)
                  ref_r8    = fx_results(i__)
                  sanity_r8 = besi1(arg_r8)
                  if(ref_r8 .EqualTo. sanity_r8) then 
                     print*, "Floating-point compare #:",i__, "PASSED!!"
                     write(*,'(2x,g24.16,2x,g24.16)') sanity_r8, ref_r8 
                  else 
                     fail_count = fail_count+1_i4 
                     print*, "Floating-point compare #:",i__, "FAILED!!"
                     write(*,'(2x,g24.16,2x,g24.16)') sanity_r8, ref_r8 
                  end if 
              end do 
              if(fail_count .gt. 0_i4) then 
                 print*, "Detected: ", fail_count, "failed results!!"
                 !stop "ERRORS DETECTED!!"
              end if 

              m_equal.m = [.false.,.false.]
              print *, "Starting main compute-comparison test."
#if 0
              ret_val =   raise(SIGTRAP)
               if(ret_val/=0_c_int) print*, "raise returned=",ret_val
#endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG1)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES1)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG1-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG1-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES1
              else 
                 print*, "[X_ARG1-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES1
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG2)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES2)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG2-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG2-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES2
              else 
                 print*, "[X_ARG2-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES2
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG3)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES2)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG3-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG3-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES3
              else 
                 print*, "[X_ARG3-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES3
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG4)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES4)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG4-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG4-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES4
              else 
                 print*, "[X_ARG4-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES4
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG5)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES5)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG5-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG5-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES5
              else 
                 print*, "[X_ARG5-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES5
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG6)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES6)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG6-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG6-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES6
              else 
                 print*, "[X_ARG6-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES6
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG7)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES7)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG7-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG7-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES7
              else 
                 print*, "[X_ARG7-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES7
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG8)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES8)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG8-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG8-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES8
              else 
                 print*, "[X_ARG8-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES8
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG9)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES9)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG1-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG9-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES9
              else 
                 print*, "[X_ARG9-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES9
              endif
              start         = rdtsc_wrap()
              actual_xmm2r8 = besi1_xmm2r8(X_ARG10)
              end           = rdtsc_wrap()
              m_equal       = xmm2r8_equalto_xmm2r8(actual_xmm2r8,FX_RES10)
              start_c       = start-RDTSC_LATENCY
              end_c         = end-RDTSC_LATENCY
              tsc_elapsed   = end_c-start_c 
              print*,"[X_ARG10-RDTSC:]", tsc_elapsed, "TSC cycles."
              if(any(m_equal.m)) then 
                 print*, "[X_ARG10-PASSED:] actual:",actual_xmm2r8,"expected=",FX_RES10
              else 
                 print*, "[X_ARG10-FAILED:] actual:",actual_xmm2r8,"expected=",FX_RES10
              endif
              print*, footer 
end subroutine unit_test_bessel_i1_values





end module mod_test_bessel_i1_values


program main 
    use mod_test_bessel_i1_values
    call unit_test_bessel_i1_values()
end program main 