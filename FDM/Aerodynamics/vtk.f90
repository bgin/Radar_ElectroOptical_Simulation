
!MIT License

!Copyright (c) 2021 USU Aero Lab

!Permission is hereby granted, free of charge, to any person obtaining a copy
!of this software and associated documentation files (the "Software"), to deal
!in the Software without restriction, including without limitation the rights
!to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
!copies of the Software, and to permit persons to whom the Software is
!furnished to do so, subject to the following conditions:

!The above copyright notice and this permission notice shall be included in all
!copies or substantial portions of the Software.

!THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
!IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
!FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
!AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
!LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
!OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
!SOFTWARE.

! Subroutines for I/O with VTK files
module vtk_mod
    ! ************Slightly modified by Bernard Gingold, 02/04/2024, 07:00PM**************
    use mod_kinds, only : i4,sp
    use helpers_mod
    use panel_mod
    use base_geom_mod
    use stl_mod

    implicit none

    type vtk_out

        character(len=:),allocatable :: filename
        integer(kind=i4):: unit
        logical :: cell_data_begun, point_data_begun, cells_subdivided, panels_already_started

        contains

            procedure :: begin => vtk_out_begin
            procedure :: vtk_out_write_points_vertices
            procedure :: vtk_out_write_points_array
            generic :: write_points => vtk_out_write_points_vertices, vtk_out_write_points_array
            procedure :: write_panels => vtk_out_write_panels
            procedure :: write_vertices => vtk_out_write_vertices
            generic :: write_point_scalars => write_point_scalars_real, write_point_scalars_integer
            procedure :: write_point_scalars_real => vtk_out_write_point_scalars_real
            procedure :: write_point_scalars_integer=> vtk_out_write_point_scalars_integer
            procedure :: write_cell_header => vtk_out_write_cell_header
            procedure :: write_point_header => vtk_out_write_point_header
            procedure :: write_cell_scalars => vtk_out_write_cell_scalars
            procedure :: write_point_vectors => vtk_out_write_point_vectors
            procedure :: write_cell_vectors => vtk_out_write_cell_vectors
            procedure :: write_cell_normals => vtk_out_write_cell_normals
            procedure :: finish => vtk_out_finish

    end type vtk_out

    
contains


    subroutine vtk_out_begin(this, filename)
        ! Starts writing out a vtk file

        implicit none

        class(vtk_out),intent(inout) :: this
        character(len=:),allocatable,intent(in) :: filename

        logical :: is_open

        ! Store filename
        this%filename = filename

        ! Check if file is opened already
        inquire(file=this%filename, opened=is_open)
        if (is_open) then
            write(*,*) "Cannot write to ", this%filename, ". Already opened."
        end if

        ! Open file
        open(newunit=this%unit, file=this%filename)

        ! Write header
        write(this%unit,'(a)') "# vtk DataFile Version 3.0"
        write(this%unit,'(a)') "MachLine results file. Generated by MachLine, USU AeroLab (c) 2023."
        write(this%unit,'(a)') "ASCII"

        ! Initialize a few checks
        this%cell_data_begun = .false.
        this%point_data_begun = .false.
        this%panels_already_started = .false.
    
    end subroutine vtk_out_begin


    subroutine vtk_out_write_points_vertices(this, vertices, mirror_plane)
        ! Writes out points to the vtk file using the MachLine vertex object

        implicit none

        class(vtk_out),intent(in) :: this
        type(vertex),dimension(:),intent(in) :: vertices
        integer(kind=i4),intent(in),optional :: mirror_plane

        integer(kind=i4):: i, N_verts
        real(kind=sp),dimension(3) :: mirror

        ! Write vertex information
        N_verts = size(vertices)
        write(this%unit,'(a)') "DATASET POLYDATA"
        write(this%unit,'(a i20 a)') "POINTS", N_verts, " float"

        ! Write out vertices
        do i=1,N_verts
            if (present(mirror_plane)) then
                mirror = mirror_across_plane(vertices(i)%loc, mirror_plane)
                write(this%unit,'(e20.12, e20.12, e20.12)') mirror(1), mirror(2), mirror(3)
            else
                write(this%unit,'(e20.12, e20.12, e20.12)') vertices(i)%loc(1), vertices(i)%loc(2), vertices(i)%loc(3)
            end if
        end do
    
    end subroutine vtk_out_write_points_vertices


    subroutine vtk_out_write_points_array(this, vertices, mirror_plane)
        ! Writes out points to the vtk file using a simple array of locations

        implicit none

        class(vtk_out),intent(in) :: this
        real(kind=sp),dimension(:,:),intent(in) :: vertices
        integer(kind=i4),intent(in),optional :: mirror_plane

        integer(kind=i4):: i, N_verts
        real(kind=sp),dimension(3) :: mirror

        ! Write vertex information
        N_verts = size(vertices)/3
        write(this%unit,'(a)') "DATASET POLYDATA"
        write(this%unit,'(a i20 a)') "POINTS", N_verts, " float"

        ! Write out vertices
        do i=1,N_verts
            if (present(mirror_plane)) then
                mirror = mirror_across_plane(vertices(:,i), mirror_plane)
                write(this%unit,'(e20.12, e20.12, e20.12)') mirror(1), mirror(2), mirror(3)
            else
                write(this%unit,'(e20.12, e20.12, e20.12)') vertices(1,i), vertices(2,i), vertices(3,i)
            end if
        end do
    
    end subroutine vtk_out_write_points_array


    subroutine vtk_out_write_panels(this, panels, mirror, vertex_index_shift, N_total_panels)
        ! Write out panels to the vtk file; only handles triangular panels

        implicit none

        class(vtk_out),intent(inout) :: this
        type(panel),dimension(:),intent(in) :: panels
        logical,intent(in) :: mirror
        integer(kind=i4),intent(in),optional :: vertex_index_shift, N_total_panels

        integer(kind=i4):: i, j, N_panels, shift

        ! Check for shift
        if (present(vertex_index_shift)) then
            shift = vertex_index_shift
        else
            shift = 0
        end if

        ! Determine panel info size
        if (present(N_total_panels)) then
            N_panels = N_total_panels
        else
            N_panels = size(panels)
        end if

        ! Write polygon header
        if (.not. this%panels_already_started) then
            this%panels_already_started = .true.
            write(this%unit,'(a i20 i20)') "POLYGONS", N_panels, N_panels*4
        end if
        
        ! Write out panels
        do i=1,size(panels)

            ! Number of vertices
            write(this%unit,'(i1) ',advance='no') 3

            ! Indices of each vertex; remember VTK files use 0-based indexing
            if (mirror) then
                do j=panels(i)%N,1,-1
                    write(this%unit,'(i20) ',advance='no') panels(i)%get_vertex_index(j) - 1 + shift
                end do
            else
                do j=1,panels(i)%N
                    write(this%unit,'(i20) ',advance='no') panels(i)%get_vertex_index(j) - 1 + shift
                end do
            end if
            
            ! Move to next line
            write(this%unit,*)

        end do
    
    end subroutine vtk_out_write_panels


    subroutine vtk_out_write_vertices(this, N_verts)
        ! Writes vertices (VTK vertices, which are different than points) to the file using default mapping (the first vertex is 1, etc.)

        implicit none

        class(vtk_out),intent(in) :: this
        integer,intent(in) :: N_verts

        integer(kind=i4):: i

        ! Write out vertices
        write(this%unit,'(a i20 i20)') "VERTICES", N_verts, N_verts*2
        do i=1,N_verts

            ! Index of each vertex
            write(this%unit,'(i1 i20)') 1, i-1

        end do
    
    end subroutine vtk_out_write_vertices


    subroutine vtk_out_write_point_header(this, N_points)
        ! Checks whether the point data header has been written and writes it if necessary

        class(vtk_out), intent(inout) :: this
        integer(kind=i4), intent(in) :: N_points

        if (.not. this%point_data_begun) then
            
            ! Write out header
            write(this%unit,'(a i20)') "POINT_DATA", N_points

            ! Set toggle that header has already been written
            this%point_data_begun = .true.

        end if
        
    end subroutine vtk_out_write_point_header


    subroutine vtk_out_write_cell_header(this, N_cells)
        ! Checks whether the cell data header has been written and writes it if necessary

        class(vtk_out), intent(inout) :: this
        integer(kind=i4), intent(in) :: N_cells

        if (.not. this%cell_data_begun) then
            
            ! Write out header
            write(this%unit,'(a i20)') "CELL_DATA", N_cells

            ! Set toggle that header has already been written
            this%cell_data_begun = .true.

        end if
        
    end subroutine vtk_out_write_cell_header


    subroutine vtk_out_write_cell_scalars(this, data, label)
        ! Writes out cell scalar data

        implicit none

        class(vtk_out),intent(inout) :: this
        real(kind=sp),dimension(:),intent(in) :: data
        character(len=*),intent(in) :: label

        integer(kind=i4):: N_cells, i, j, N, N_cycle

        ! Figure out size of dataset
        N_cells = size(data)
        N_cycle = 1
        N = N_cells

        ! Write header
        call this%write_cell_header(N_cells)

        ! Write data
        write(this%unit,'(a, a, a)') "SCALARS ", label, " float 1"
        write(this%unit,'(a)') "LOOKUP_TABLE default"
        do i=1,N
            write(this%unit, '(e20.12)') data((i-1)*N_cycle+1)
        end do
    
    end subroutine vtk_out_write_cell_scalars


    subroutine vtk_out_write_cell_vectors(this, data, label)
        ! Writes out cell vector data

        implicit none

        class(vtk_out),intent(inout) :: this
        real(kind=sp),dimension(:,:),intent(in) :: data
        character(len=*),intent(in) :: label

        integer(kind=i4):: N_cells, i, j, N_cycle, N

        ! Number of cells and subdivisions
        N_cells = size(data)/3
        N_cycle = 1
        N = N_cells

        ! Write cell data header
        call this%write_cell_header(N_cells)

        ! Write header
        write(this%unit,'(a, a, a)') "VECTORS ", label, " float"

        ! Loop through cells
        do i=1,N
            write(this%unit,'(e20.12, e20.12, e20.12)') data(1,(i-1)*N_cycle+1), data(2,(i-1)*N_cycle+1), data(3,(i-1)*N_cycle+1)
        end do
    
    end subroutine vtk_out_write_cell_vectors


    subroutine vtk_out_write_cell_normals(this, panels, mirror_plane)
        ! Writes out cell normals

        implicit none

        class(vtk_out),intent(inout) :: this
        type(panel),dimension(:),intent(in) :: panels
        integer(kind=i4),intent(in),optional :: mirror_plane

        integer(kind=i4):: N_cells, i, j
        real(kind=sp),dimension(3) :: mirror

        ! Write cell data header
        N_cells = size(panels)
        call this%write_cell_header(N_cells)

        ! Write vectors
        write(this%unit,'(a)') "NORMALS normals float"
        do i=1,N_cells

            ! Mirror
            if (present(mirror_plane)) then
                mirror = mirror_across_plane(panels(i)%n_g, mirror_plane)
                write(this%unit,'(e20.12, e20.12, e20.12)') mirror(1), mirror(2), mirror(3)

            ! Original
            else
                write(this%unit,'(e20.12, e20.12, e20.12)') panels(i)%n_g(1), panels(i)%n_g(2), panels(i)%n_g(3)
            end if
        end do
    
    end subroutine vtk_out_write_cell_normals


    subroutine vtk_out_write_point_scalars_real(this, data, label)
        ! Writes out point scalar data

        implicit none

        class(vtk_out),intent(inout) :: this
        real(kind=sp),dimension(:),intent(in) :: data
        character(len=*),intent(in) :: label

        integer(kind=i4):: i, N_points

        ! Write point data header
        N_points = size(data)
        call this%write_point_header(N_points)

        ! Write data
        write(this%unit,'(a, a, a)') "SCALARS ", label, " float 1"
        write(this%unit,'(a)') "LOOKUP_TABLE default"
        do i=1,N_points
            write(this%unit,'(e20.12)') data(i)
        end do
    
    end subroutine vtk_out_write_point_scalars_real


    subroutine vtk_out_write_point_scalars_integer(this, data, label)
        ! Writes out point scalar data

        implicit none

        class(vtk_out),intent(inout) :: this
        integer(kind=i4),dimension(:),intent(in) :: data
        character(len=*),intent(in) :: label

        integer(kind=i4):: i, N_points

        ! Write point data header
        N_points = size(data)
        call this%write_point_header(N_points)

        ! Write data
        write(this%unit,'(a, a, a)') "SCALARS ", label, " int 1"
        write(this%unit,'(a)') "LOOKUP_TABLE default"
        do i=1,N_points
            write(this%unit,'(i12)') data(i)
        end do
    
    end subroutine vtk_out_write_point_scalars_integer


    subroutine vtk_out_write_point_vectors(this, data, label)
        ! Writes out point vector data

        implicit none

        class(vtk_out),intent(inout) :: this
        real(kind=sp),dimension(:,:),intent(in) :: data
        character(len=*),intent(in) :: label

        integer(kind=i4):: N_points, i

        ! Write cell data header
        N_points = size(data)/3
        call this%write_point_header(N_points)

        ! Write vectors
        write(this%unit,'(a, a, a)') "VECTORS ", label, " float"
        do i=1,N_points
            write(this%unit,'(e20.12, e20.12, e20.12)') data(1,i), data(2,i), data(3,i)
        end do
    
    end subroutine vtk_out_write_point_vectors
    

    subroutine vtk_out_finish(this)
        ! Closes the file

        implicit none

        class(vtk_out),intent(in) :: this

        ! Close the file
        close(this%unit)
    
    end subroutine vtk_out_finish


    subroutine load_surface_vtk(mesh_file, N_verts, N_panels, vertices, panels)
        ! Loads a surface mesh from a vtk file. Only a body.

        implicit none

        character(len=:),allocatable,intent(in) :: mesh_file
        integer(kind=i4),intent(out) :: N_verts, N_panels
        type(vertex),dimension(:),allocatable,intent(out) :: vertices
        type(panel),dimension(:),allocatable,intent(out) :: panels

        character(len=200) :: line
        integer(kind=i4):: ind, ver, unit

        ! Determine version
        open(newunit=unit, file=mesh_file)
        read(unit,'(a)') line
        ind = index(line, 'Version')
        read(line(ind+8:ind+8),*) ver
        close(unit)

        ! Load based on version
        select case (ver)

        case (3)
            call load_surface_vtk_ver_3(mesh_file, N_verts, N_panels, vertices, panels)

        case (5)
            call load_surface_vtk_ver_5(mesh_file, N_verts, N_panels, vertices, panels)

        case default
            write(*,*) "!!! VTK file version ", ver, " not recognized. Quitting..."
            stop

        end select
    
    end subroutine load_surface_vtk


    subroutine load_surface_vtk_ver_3(mesh_file, N_verts, N_panels, vertices, panels)
        ! Loads a surface mesh from a vtk file version 3. Only a body.

        implicit none

        character(len=:),allocatable,intent(in) :: mesh_file
        integer(kind=i4),intent(out) :: N_verts, N_panels
        type(vertex),dimension(:),allocatable,intent(out) :: vertices
        type(panel),dimension(:),allocatable,intent(out) :: panels

        character(len=200) :: dummy_read, line
        real(kind=sp),dimension(:,:),allocatable :: vertex_locs
        integer(kind=i4):: i, N, i1, i2, i3, N_duplicates, unit
        integer(kind=i4),dimension(:),allocatable :: new_ind

        ! Open file
        open(newunit=unit, file=mesh_file)

            ! Determine number of vertices
            read(unit,*) ! Header
            read(unit,*) ! Header
            read(unit,*) ! Header
            read(unit,*) ! Header
            read(unit,*) dummy_read, N_verts, dummy_read

            ! Store vertices
            allocate(vertex_locs(3,N_verts))

            ! Read in one from each line
            do i=1,N_verts
                read(unit,*) vertex_locs(1,i), vertex_locs(2,i), vertex_locs(3,i)
            end do

            ! Find duplicates
            call collapse_duplicate_vertices(vertex_locs, vertices, N_verts, N_duplicates, new_ind)

            ! Get to start of polygons
            read(unit,'(a)') line
            do while (index(line, 'POLYGONS') == 0)
                read(unit,'(a)') line
            end do

            ! Determine number of panels
            read(line,*) dummy_read, N_panels, dummy_read

            ! Allocate panel array
            allocate(panels(N_panels))

            ! Read in panels
            do i=1,N_panels

                ! Get vertex indices
                read(unit,'(a)') dummy_read

                ! Check it's a triangular panel
                if (dummy_read(1:2) == '3 ') then
                    read(dummy_read,*) N, i1, i2, i3
                else
                    write(*,*) "!!! MachLine supports only triangular panels."
                    stop
                end if

                ! Initialize; need +1 because VTK uses 0-based indexing
                call panels(i)%init(vertices(new_ind(i1+1)), vertices(new_ind(i2+1)), vertices(new_ind(i3+1)), i)

            end do

        close(unit)
    
    end subroutine load_surface_vtk_ver_3


    subroutine load_surface_vtk_ver_5(mesh_file, N_verts, N_panels, vertices, panels)
        ! Loads a surface mesh from a vtk file. Only a body.

        implicit none

        character(len=:),allocatable,intent(in) :: mesh_file
        integer(kind=i4),intent(out) :: N_verts, N_panels
        type(vertex),dimension(:),allocatable,intent(out) :: vertices
        type(panel),dimension(:),allocatable,intent(out) :: panels

        character(len=200) :: dummy_read, line
        real(kind=sp),dimension(:,:),allocatable :: vertex_locs
        integer(kind=i4):: i, N, i1, i2, i3, N_duplicates, unit, ind, N_words
        integer(kind=i4),dimension(:),allocatable :: new_ind, vertex_inds

        ! Open file
        open(newunit=unit, file=mesh_file)

            ! Determine number of vertices
            read(unit,*) ! Header
            read(unit,*) ! Header
            read(unit,*) ! Header
            read(unit,*) ! Header
            read(unit,*) dummy_read, N_verts, dummy_read

            ! Store vertices
            allocate(vertex_locs(3,N_verts))

            ! Read in three from each line
            do i=1,N_verts/3
                read(unit,*) vertex_locs(1,3*(i-1)+1), vertex_locs(2,3*(i-1)+1), vertex_locs(3,3*(i-1)+1), &
                             vertex_locs(1,3*(i-1)+2), vertex_locs(2,3*(i-1)+2), vertex_locs(3,3*(i-1)+2), &
                             vertex_locs(1,3*(i-1)+3), vertex_locs(2,3*(i-1)+3), vertex_locs(3,3*(i-1)+3)
            end do

            ! Get last line
            if (mod(N_verts, 3) == 1) then
                read(unit,*) vertex_locs(1,N_verts), vertex_locs(2,N_verts), vertex_locs(3,N_verts)
            else if (mod(N_verts, 3) == 2) then
                read(unit,*) vertex_locs(1,N_verts-1), vertex_locs(2,N_verts-1), vertex_locs(3,N_verts-1), &
                             vertex_locs(1,N_verts), vertex_locs(2,N_verts), vertex_locs(3,N_verts)
            end if

            ! Find duplicates
            call collapse_duplicate_vertices(vertex_locs, vertices, N_verts, N_duplicates, new_ind)

            ! Get to start of polygons
            read(unit,'(a)') line
            do while (index(line, 'POLYGONS') == 0 .and. index(line, 'CELLS') == 0)
                read(unit,'(a)') line
            end do

            ! Determine number of panels
            read(line,*) dummy_read, N_panels, dummy_read
            N_panels = N_panels - 1

            ! Allocate panel array
            allocate(panels(N_panels))

            ! Get to start of mapping
            read(unit,'(a)') line
            do while (index(line, 'CONNECTIVITY') == 0)
                read(unit,'(a)') line
            end do

            ! Read in three panels at a time
            ind = 0
            do while (.true.)

                ! Update index
                ind = ind + 1

                ! Check we've not gone over
                if (ind > N_panels) exit

                ! Read in line
                read(unit,'(a)') line

                ! Get number of points on the line
                N_words = get_N_words_in_string(line)

                ! Allocate vertex indices
                if (allocated(vertex_inds)) deallocate(vertex_inds)
                allocate(vertex_inds(N_words))
                read(line,*) vertex_inds

                ! Initialize first panel; need +1 because VTK uses 0-based indexing
                call panels(ind)%init(vertices(new_ind(vertex_inds(1)+1)), &
                                      vertices(new_ind(vertex_inds(2)+1)), &
                                      vertices(new_ind(vertex_inds(3)+1)), &
                                      ind)

                ! Move on to second panel
                if (N_words > 3) then
                    ind = ind + 1

                    ! Initialize second panel
                    call panels(ind)%init(vertices(new_ind(vertex_inds(4)+1)), &
                                          vertices(new_ind(vertex_inds(5)+1)), &
                                          vertices(new_ind(vertex_inds(6)+1)), &
                                          ind)

                    ! Move on to third panel
                    if (N_words > 6) then
                        ind = ind + 1

                        ! Initialize second panel
                        call panels(ind)%init(vertices(new_ind(vertex_inds(7)+1)), &
                                              vertices(new_ind(vertex_inds(8)+1)), &
                                              vertices(new_ind(vertex_inds(9)+1)), &
                                              ind)
                    end if
                end if


            end do

        close(unit)
    
    end subroutine load_surface_vtk_ver_5


    function get_N_words_in_string(line) result(N_words)
        ! Counts the number of words in the line

        implicit none
        
        character(len=*),intent(in) :: line

        integer(kind=i4):: N_words

        integer(kind=i4):: i
        logical :: on_space

        ! Loop through each character
        on_space = .true.
        N_words = 0
        do i=1,len(line)

            ! Check if we're on a space
            if (line(i:i) == ' ') then

                on_space = .true.

            ! If we're not on a space but we were, then we've moved onto a word
            else if (on_space) then
                N_words = N_words + 1
                on_space = .false.
            end if

        end do
        
    end function get_N_words_in_string

    
end module vtk_mod
